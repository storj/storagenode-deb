#!/bin/bash

set -e

# Source debconf library
. /usr/share/debconf/confmodule

function valid_ipv4 () {
    ip=$1
    if [[ $ip =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ ]]; then
        return 0
    fi
    return 1
}

function valid_ipv6 () {
    ip=$1
    if [[ $ip =~ ^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$ ]] ; then
        return 0
    fi
    return 1
}

function valid_port () {
    port=$1
    if [[ $port =~ [0-9]{1,5} ]]; then
      return 0
    fi
    return 1
}

function valid_ip () {
    ip=$1
    if valid_ipv4 $ip; then return 0; fi
    if valid_ipv6 $ip; then return 0; fi
    return 1
}

#db_version 2.0
db_capb backup

# possible states
REQUIREMENTS=1
IDENTITY_DIR=2
WALLET_ADDRESS=3
EMAIL_ADDRESS=4
IP_ADDRESS=5
END_STATE=6

STATE=$REQUIREMENTS
ERR_NO_ERROR=0
ERR_CONTINUE=1
ERR_BACK=2

ERR_STATE=0

# ask the user if they want to continue by prompting
# the template provided as first argument.
# sets the error state corresponding to the user's answer.
error_ask_continue () {
      ERR_STATE=$ERR_BACK
      db_input high $1
      db_go
      db_get $1
      if [ "$RET" = "true" ]; then
            ERR_STATE=$ERR_CONTINUE
      fi
}

# select the next state to go to, i.e. 'next state'
# if everything is ok or if the user has chosen to
# continue
next_state () {
      if [ "$ERR_STATE" != "$ERR_BACK" ]; then
            STATE=$(($STATE + 1))
      fi
      ERR_STATE=$ERR_NO_ERROR
}

go_back () {
      STATE=$(($STATE - 1))
      ERR_STATE=$ERR_NO_ERROR
}

while [ "$STATE" != 0 -a "$STATE" != "$END_STATE" ]; do
case "$STATE" in
      # requirements infos
      "$REQUIREMENTS")
            db_input high storagenode/requirements || true
            db_go;
            next_state
      ;;
      "$IDENTITY_DIR")
            # identity directory
            db_input high storagenode/identitydir || true
            if db_go; then
                  # check that the directory exists
                  db_get storagenode/identitydir
		  provided_dir=`echo "$RET" | xargs`
		  if [ -z "$provided_dir" ]; then
                        error_ask_continue storagenode/identitydir/empty_string_continue
                  elif [ ! -d $provided_dir ] ; then		  
                        error_ask_continue storagenode/identitydir/directory_does_not_exist_continue
                  else
                        if [ ! -f "$provided_dir/ca.cert" ]; then
                              error_ask_continue storagenode/identitydir/no_ca_cert_continue
                        fi
                        if [ "$ERR_STATE" != "$ERR_BACK" -a ! -f "$provided_dir/identity.cert" ]; then
                              error_ask_continue storagenode/identitydir/no_identity_cert_continue
                        fi
                        if [ "$ERR_STATE" != "$ERR_BACK" -a ! -f "$provided_dir/identity.key" ]; then
                              error_ask_continue storagenode/identitydir/no_identity_key_continue
                        fi
                  fi
                  next_state
            else
                  # the user has chosen to go back
                  go_back
            fi
      ;;
      "$WALLET_ADDRESS")
            db_input high storagenode/wallet || true
            if db_go; then
                  db_get storagenode/wallet
                  wallet="$RET"
                  if [[ ! "${wallet}" =~ ^0x*$ ]] ; then
                        error_ask_continue storagenode/wallet/wrong_prefix_continue
                  elif  ! [[ "${wallet}" =~ ^0x.{40}$ ]]; then
                        error_ask_continue storagenode/wallet/wrong_nb_char_continue
                  elif  ! [[ "${wallet}" =~ ^0x[a-zA-Z0-9]{40}$ ]]; then
                        error_ask_continue storagenode/wallet/incorrect_char_continue
                  fi
                  next_state
            else
                  # the user has chosen to go back
                  go_back
            fi
      ;;
      "$EMAIL_ADDRESS")
            db_input high storagenode/email || true
            if db_go; then
                  db_get storagenode/email
                  email="$RET"
                  if [[ ! "${email}" =~ ^.+\@.+\..+$ ]]; then
                        error_ask_continue storagenode/email/wrong_format_continue
                  fi
                  next_state
            else
                  go_back
            fi
      ;;
      "$IP_ADDRESS")
            db_input high storagenode/external_addr || true
            if db_go; then
                  db_get storagenode/external_addr
                  ip_port="$RET"
                  ip="${ip_port%:*}"
                  port="${ip_port##*:}"

                  if ! valid_ip $ip ;  then
                        error_ask_continue storagenode/external_addr/not_ip_port_continue
                  elif ! valid_port $ip ;  then
                        error_ask_continue storagenode/external_addr/not_ip_port_continue
                  fi
                  next_state
            else
                  go_back
            fi
      esac
done

# storage directory
#while [ "$storagedir" = "" ]; do
      # Get storage dir
#      db_input high storagenode/storagedir || true
#      db_go
#      storagedir="$RET"
#done

# allocated disk space
#db_input high storagenode/diskspace || true
#db_go

# advertised bandwidth
#db_input high storagenode/bandwidth || true
#db_go


